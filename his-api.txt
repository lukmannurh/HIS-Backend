======== FILE: ./.env.example ========
# .env.example

# === Database Configuration ===
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASS=password
DB_NAME=hoax_checker_db

# === JWT ===
JWT_SECRET=your_jwt_secret
JWT_REFRESH_SECRET=your_refresh_jwt_secret
ENCRYPTION_KEY=your_64_characters_hex_encryption_key_here

# === Hoax Checker (e.g. Hugging Face, Gemini, etc.) ===
HF_API_TOKEN=hf_XXXXXXXXXXXXXXXXX
GEMINI_API_KEY=AIzaSyD-xxxx

# === Google Fact Check Tools (optional) ===
GOOGLE_FACTCHECK_API_KEY=xxxxxxx

# === Node Server PORT ===
PORT=3000

# === Logging / Node Env ===
NODE_ENV=development

# === Additional Variables for Docker, Jenkins, etc. ===
# DOCKER_USER=
# DOCKER_PASS=
# ...
======== FILE: ./.gitignore ========
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by coverage tools
coverage

# nyc test coverage
.nyc_output

# Next.js build output
.next

# Gatsby files
.cache/

# Nuxt.js build / generated files
.nuxt

# Vuepress build output
.vuepress/dist

# Production build output
dist/
build/
out/

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory
.snowpack

# TypeScript cache
*.tsbuildinfo

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# dotenv environment variables file
.env
.env.test
.env.*.local

# pm2 Log files
.pm2/logs
.pm2/pids
.pm2/rpc.sock
.pm2/pub.sock

# Parcel cache
.cache

# Microsoft Visual Studio Code workspace settings
.vscode/*

# macOS system files
.DS_Store

# Linux/macOS executable files
*.out
*.exe

# Debug and profiling
*.prof
*.trace
======== FILE: ./babel.config.cjs ========
// babel.config.cjs
module.exports = {
  presets: [
    [
      "@babel/preset-env",
      {
        targets: {
          node: "current", // Menargetkan versi Node saat ini
        },
        modules: "auto", // Biarkan Babel mengatur modul sesuai kebutuhan
      },
    ],
  ],
};
======== FILE: ./docker-compose.yml ========
version: "3.8"

services:
  db:
    image: postgres:15-alpine
    container_name: hoax-checker-db
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  app:
    build: .
    container_name: hoax-checker-app
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASS}
      DB_NAME: ${DB_NAME}
      JWT_SECRET: ${JWT_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      HF_API_TOKEN: ${HF_API_TOKEN}
      GEMINI_API_KEY: ${GEMINI_API_KEY}
      GOOGLE_FACTCHECK_API_KEY: ${GOOGLE_FACTCHECK_API_KEY}
      NODE_ENV: ${NODE_ENV}
    depends_on:
      - db

  grafana:
    image: grafana/grafana-oss:latest
    container_name: hoax-checker-grafana
    ports:
      - "3001:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: "admin"  # atau dari env
    depends_on:
      - db
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  db_data:
  grafana_data:
======== FILE: ./Dockerfile ========
# 1. Gunakan base image Node LTS
FROM node:18-alpine

# 2. Buat direktori kerja
WORKDIR /usr/src/app

# 3. Salin package.json dan package-lock.json
COPY package*.json ./

# 4. Install dependencies
RUN npm install

# 5. Salin semua source code ke container
COPY . .

# 6. Expose port
EXPOSE 3000

# 7. Jalankan perintah
CMD ["npm", "run", "start"]
======== FILE: ./his-api.txt ========
======== FILE: ./Jenkinsfile ========
pipeline {
    agent any

    environment {
        // Mendefinisikan versi Node.js
        NODE_VERSION = '20.x'
        // Mendefinisikan variabel lingkungan (jika ada)
        // Untuk keamanan, variabel sensitif harus disimpan di kredensial Jenkins
    }

    tools {
        // Instalasi Node.js menggunakan plugin NodeJS
        nodejs NODE_VERSION
    }

    stages {
        stage('Checkout') {
            steps {
                // Clone source code
                git branch: 'main', url: 'https://github.com/lukmannurh/HIS-Backend.git'
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'npm install'
            }
        }

        stage('Lint') {
            steps {
                sh 'npm run lint'
            }
        }

        stage('Run Tests') {
            steps {
                sh 'npm run test'
            }
        }

        stage('Build Docker Image') {
            steps {
                sh 'docker build -t my-hoax-checker-app:latest .'
            }
        }

        stage('Push Docker Image') {
            when {
                expression { return env.PUSH_DOCKER == 'true' }
            }
            steps {
                withCredentials([usernamePassword(credentialsId: 'dockerhub-cred', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                    sh 'echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin'
                    sh 'docker tag my-hoax-checker-app:latest my-dockerhub-namespace/my-hoax-checker-app:latest'
                    sh 'docker push my-dockerhub-namespace/my-hoax-checker-app:latest'
                }
            }
        }

        stage('Deploy') {
            steps {
                // Deploy menggunakan docker-compose
                sh 'docker-compose down'
                sh 'docker-compose up -d --build'
            }
        }
    }

    post {
        always {
            // Cleanup
            sh 'docker logout || true'
            cleanWs()
        }
        success {
            echo 'Pipeline berhasil!'
        }
        failure {
            echo 'Pipeline gagal!'
        }
    }
}
======== FILE: ./jest.config.cjs ========
// jest.config.cjs
module.exports = {
  testEnvironment: 'node',
  moduleFileExtensions: ['js', 'mjs'],
  transform: {
    '^.+\\.mjs$': 'babel-jest',
    '^.+\\.js$': 'babel-jest',
  },
  coverageDirectory: 'coverage',
  collectCoverage: true,
};
======== FILE: ./package.json ========
{
  "name": "hamlet-information-system-backend",
  "version": "1.0.0",
  "type": "module",
  "main": "src/server.js",
  "scripts": {
    "dev": "nodemon src/server.js",
    "start": "node src/server.js",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "migrate": "sequelize-cli db:migrate --config sequelize.config.cjs"
  },
  "dependencies": {
    "@google/generative-ai": "^0.21.0",
    "axios": "^1.4.0",
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.0.1",
    "helmet": "^8.0.0",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "pg": "^8.11.1",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.31.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/preset-env": "^7.26.0",
    "babel-jest": "^29.7.0",
    "jest": "^29.7.0",
    "madge": "^8.0.0",
    "nodemon": "^2.0.22",
    "sequelize-cli": "^6.6.1",
    "supertest": "^7.0.0"
  }
}
======== FILE: ./README.md ========
# Hamlet Information System Backend

Proyek **HIS Hoax Checker** dengan Node.js, Express, PostgreSQL, serta integrasi Hoax Checking API (Hugging Face, Gemini, dll.). Dilengkapi CI/CD (Jenkins), Docker, dan contoh monitoring (Grafana).

## Fitur
1. Authentication (JWT).
2. Role-based access (owner, admin, user).
3. Laporan/Report dengan validasi hoax (panggil Hoax Checking API).
4. CI/CD pipeline (Jenkinsfile).
5. Containerization (Docker, docker-compose).
6. Migrations (Sequelize).
7. Contoh Monitoring (Grafana).

## Persiapan

- Node.js >= 16
- PostgreSQL
- (Optional) Docker & Docker Compose
- (Optional) Jenkins

## Menjalankan Secara Lokal

1. Copy `.env.example` ke `.env` lalu atur variabel (DB_HOST, JWT_SECRET, dsb.).
2. `npm install`
3. Jalankan migrations (opsional):
   ```bash
   npx sequelize-cli db:migrate
======== FILE: ./sequelize.config.cjs ========
const path = require('path'); // Import modul path
require('dotenv').config(); // Memuat variabel lingkungan dari .env

module.exports = {
  development: {
    username: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASS || 'password',
    database: process.env.DB_NAME || 'hoax_checker_db',
    host: process.env.DB_HOST || '127.0.0.1',
    port: process.env.DB_PORT || 5432,
    dialect: 'postgres',
    logging: false,
    migrationStorage: 'sequelize',
    seederStorage: 'sequelize',
    migrations: {
      path: path.resolve(__dirname, 'src/migrations'), // Path absolut ke migrations
    },
    models: {
      path: path.resolve(__dirname, 'src/models'), // Path absolut ke models
      pattern: /\.js$/,
    },
    seeders: {
      path: path.resolve(__dirname, 'src/seeders'), // Path absolut ke seeders
      pattern: /\.js$/,
    },
  },
  test: {
    username: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASS || 'password',
    database: process.env.DB_NAME_TEST || 'hoax_checker_db_test',
    host: process.env.DB_HOST || '127.0.0.1',
    port: process.env.DB_PORT || 5432,
    dialect: 'postgres',
    logging: false,
    migrationStorage: 'sequelize',
    seederStorage: 'sequelize',
    migrations: {
      path: path.resolve(__dirname, 'src/migrations'),
    },
    models: {
      path: path.resolve(__dirname, 'src/models'),
      pattern: /\.js$/,
    },
    seeders: {
      path: path.resolve(__dirname, 'src/seeders'),
      pattern: /\.js$/,
    },
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT || 5432,
    dialect: 'postgres',
    logging: false,
    migrationStorage: 'sequelize',
    seederStorage: 'sequelize',
    migrations: {
      path: path.resolve(__dirname, 'src/migrations'),
    },
    models: {
      path: path.resolve(__dirname, 'src/models'),
      pattern: /\.js$/,
    },
    seeders: {
      path: path.resolve(__dirname, 'src/seeders'),
      pattern: /\.js$/,
    },
  },
};
======== FILE: ./src/app.js ========
import express from "express";
import cors from "cors";
import helmet from "helmet";
import morgan from "morgan";

import authRoutes from "./routes/authRoutes.js";
import reportRoutes from "./routes/reportRoutes.js";
import userRoutes from "./routes/userRoutes.js";
import logger from "./middlewares/loggingMiddleware.js";
import setupSwagger from './swagger.js';

const app = express();

// Setup Swagger
setupSwagger(app);

// Middleware
app.use(helmet()); // Tambahkan security headers
app.use(cors());
app.use(express.json());

// HTTP request logging menggunakan morgan dan winston
app.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/reports", reportRoutes);
app.use("/api/users", userRoutes);

// 404 handler
app.use((req, res, next) => {
  res.status(404).json({ message: "Endpoint tidak ditemukan" });
});

// Error handling middleware (pastikan setelah semua app.use lainnya)
app.use((err, req, res, next) => {
  logger.error(`${req.method} ${req.url} - ${err.message}`);
  res.status(500).json({ message: "Internal server error" });
});

export default app;
======== FILE: ./src/controllers/authController.js ========
import {
  registerUser,
  loginUser,
  refreshAccessToken,
} from "../services/authService.js";

export const register = async (req, res) => {
  try {
    const { username, email, password, role } = req.body;
    const user = await registerUser({ username, email, password, role });

    // Anda harus mengganti akses_token dan refresh_token dengan token yang sebenarnya
    return res.status(201).json({
      message: "User berhasil dibuat",
      data: user,
    });
  } catch (error) {
    if (error.status && error.message) {
      return res.status(error.status).json({ message: error.message });
    }
    // Error internal server
    return res.status(500).json({ message: "Internal server error" });
  }
};

export const login = async (req, res) => {
  try {
    const { username, password } = req.body;
    const result = await loginUser({ username, password });

    return res.json({
      message: "Login berhasil",
      ...result,
    });
  } catch (error) {
    if (error.status && error.message) {
      return res.status(error.status).json({ message: error.message });
    }
    // Error internal server
    return res.status(500).json({ message: "Internal server error" });
  }
};

export const refresh = async (req, res) => {
  try {
    const { refreshToken } = req.body;
    const result = await refreshAccessToken(refreshToken);

    return res.json(result);
  } catch (error) {
    if (error.status && error.message) {
      return res.status(error.status).json({ message: error.message });
    }
    // Error internal server
    return res.status(500).json({ message: "Internal server error" });
  }
};
======== FILE: ./src/controllers/reportController.js ========
import db from "../models/index.js";
import { checkHoax } from "../services/hoaxChecker.js";
import logger from "../middlewares/loggingMiddleware.js";

const Report = db.Report;

/**
 * @swagger
 * /api/reports:
 *   post:
 *     summary: Membuat laporan baru
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - content
 *               - link
 *             properties:
 *               title:
 *                 type: string
 *                 description: Judul laporan
 *               content:
 *                 type: string
 *                 description: Isi laporan
 *               link:
 *                 type: string
 *                 format: uri
 *                 description: URL sumber terkait laporan
 *             example:
 *               title: "Hoax Example"
 *               content: "This is an example of a hoax report."
 *               link: "https://example.com/hoax"
 *     responses:
 *       201:
 *         description: Laporan berhasil dibuat
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Report'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
export async function createReport(req, res) {
  try {
    const { title, content, link } = req.body;
    const userId = req.userId;

    const { validationStatus, validationDetails } = await checkHoax(
      content,
      link
    );

    const newReport = await Report.create({
      title,
      content,
      userId,
      validationStatus,
      validationDetails,
    });

    return res.status(201).json({
      message: "Report berhasil dibuat",
      data: newReport,
    });
  } catch (error) {
    logger.error(`Error in createReport: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
}

/**
 * @swagger
 * /api/reports:
 *   get:
 *     summary: Mengambil semua laporan
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Daftar semua laporan
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Report'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
export async function getAllReports(req, res) {
  try {
    let reports;
    if (req.userRole === "admin" || req.userRole === "owner") {
      reports = await Report.findAll({
        order: [["createdAt", "DESC"]],
        include: ["user"],
      });
    } else {
      reports = await Report.findAll({
        where: { userId: req.userId },
        order: [["createdAt", "DESC"]],
        include: ["user"],
      });
    }
    return res.json(reports);
  } catch (error) {
    logger.error(`Error in getAllReports: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
}

/**
 * @swagger
 * /api/reports/{reportId}:
 *   get:
 *     summary: Mengambil laporan berdasarkan ID
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: reportId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik laporan
 *     responses:
 *       200:
 *         description: Informasi laporan
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Report'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Laporan tidak ditemukan
 */
export async function getReportById(req, res) {
  try {
    const { reportId } = req.params;
    const report = await Report.findOne({
      where: { id: reportId },
      include: ["user"],
    });
    if (!report) {
      return res.status(404).json({ message: "Report tidak ditemukan" });
    }

    if (
      report.userId === req.userId ||
      req.userRole === "admin" ||
      req.userRole === "owner"
    ) {
      return res.json(report);
    } else {
      return res.status(403).json({ message: "Forbidden" });
    }
  } catch (error) {
    logger.error(`Error in getReportById: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
}

/**
 * @swagger
 * /api/reports/{reportId}:
 *   delete:
 *     summary: Menghapus laporan berdasarkan ID
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: reportId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik laporan
 *     responses:
 *       200:
 *         description: Laporan berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: Pesan status
 *               example:
 *                 message: "Report berhasil dihapus"
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Laporan tidak ditemukan
 */
export async function deleteReport(req, res) {
  try {
    const { reportId } = req.params;
    const report = await Report.findByPk(reportId);

    if (!report) {
      return res.status(404).json({ message: "Report tidak ditemukan" });
    }

    if (
      report.userId === req.userId ||
      req.userRole === "admin" ||
      req.userRole === "owner"
    ) {
      await report.destroy();
      return res.json({ message: "Report berhasil dihapus" });
    } else {
      return res.status(403).json({ message: "Forbidden" });
    }
  } catch (error) {
    logger.error(`Error in deleteReport: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
}
======== FILE: ./src/controllers/userController.js ========
import { User } from "../models/index.js";
import bcrypt from "bcrypt";
import logger from "../middlewares/loggingMiddleware.js";

/**
 * @swagger
 * /api/users:
 *   get:
 *     summary: Mengambil semua pengguna (admin/owner)
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Daftar semua pengguna
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/User'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
export const getAllUsers = async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: [
        "id",
        "username",
        "email",
        "role",
        "fullName",
        "address",
        "age",
        "gender",
        "createdAt",
        "updatedAt",
      ],
      order: [["createdAt", "DESC"]],
    });
    return res.json(users);
  } catch (error) {
    logger.error(`Error in getAllUsers: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
};

/**
 * @swagger
 * /api/users/{userId}:
 *   get:
 *     summary: Mengambil pengguna berdasarkan ID
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik pengguna
 *     responses:
 *       200:
 *         description: Informasi pengguna
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Pengguna tidak ditemukan
 */
export async function getUserById(req, res) {
  try {
    const { userId } = req.params;
    const requestingUserId = req.userId; // dari authMiddleware
    const requestingUserRole = req.userRole; // role dari JWT

    const targetUser = await User.findByPk(userId);
    if (!targetUser) {
      return res.status(404).json({ message: "User tidak ditemukan" });
    }

    // Role-based logic:
    // - If admin or owner => allowed
    // - If user => only allowed if userId === requestingUserId
    if (
      requestingUserRole !== "admin" &&
      requestingUserRole !== "owner" &&
      requestingUserId !== userId
    ) {
      return res.status(403).json({ message: "Forbidden" });
    }

    // Pilih field yang ditampilkan
    return res.json({
      id: targetUser.id,
      username: targetUser.username,
      email: targetUser.email,
      role: targetUser.role,
      fullName: targetUser.fullName,
      address: targetUser.address,
      age: targetUser.age,
      gender: targetUser.gender,
      createdAt: targetUser.createdAt,
      updatedAt: targetUser.updatedAt,
    });
  } catch (error) {
    logger.error(`Error in getUserById: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
};

/**
 * @swagger
 * /api/users/{userId}:
 *   delete:
 *     summary: Menghapus pengguna (role=user) oleh admin/owner
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik pengguna
 *     responses:
 *       200:
 *         description: Pengguna berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: Pesan status
 *               example:
 *                 message: "User (role=user) berhasil dihapus"
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: User tidak ditemukan
 */
export const deleteUser = async (req, res) => {
  try {
    const { userId } = req.params;
    const targetUser = await User.findByPk(userId);

    if (!targetUser) {
      return res.status(404).json({ message: "User tidak ditemukan" });
    }

    // Tidak boleh hapus admin/owner di sini
    if (targetUser.role === "admin" || targetUser.role === "owner") {
      return res
        .status(403)
        .json({ message: "Tidak dapat menghapus admin atau owner melalui endpoint ini" });
    }

    await targetUser.destroy();
    return res.json({ message: "User (role=user) berhasil dihapus" });
  } catch (error) {
    logger.error(`Error in deleteUser: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
};

/**
 * @swagger
 * /api/users/admin/{adminId}:
 *   delete:
 *     summary: Menghapus admin (hanya oleh owner)
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: adminId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik admin
 *     responses:
 *       200:
 *         description: Admin berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: Pesan status
 *               example:
 *                 message: "Admin berhasil dihapus"
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Admin tidak ditemukan
 */
export const deleteAdmin = async (req, res) => {
  try {
    const { adminId } = req.params;
    const targetAdmin = await User.findOne({
      where: { id: adminId, role: "admin" },
    });

    if (!targetAdmin) {
      return res.status(404).json({ message: "Admin tidak ditemukan" });
    }

    await targetAdmin.destroy();
    return res.json({ message: "Admin berhasil dihapus" });
  } catch (error) {
    logger.error(`Error in deleteAdmin: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
};

/**
 * @swagger
 * /api/users/profile:
 *   put:
 *     summary: Memperbarui profil pengguna (update diri sendiri)
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               password:
 *                 type: string
 *                 format: password
 *                 description: Kata sandi baru (opsional)
 *               fullName:
 *                 type: string
 *                 description: Nama lengkap baru (opsional)
 *               address:
 *                 type: string
 *                 description: Alamat baru (opsional)
 *               age:
 *                 type: integer
 *                 description: Usia baru (opsional)
 *               gender:
 *                 type: string
 *                 description: Jenis kelamin baru (opsional)
 *             example:
 *               password: "NewPassword123!"
 *               fullName: "Jane Doe"
 *               address: "456 Another St"
 *               age: 28
 *               gender: "Female"
 *     responses:
 *       200:
 *         description: Profil berhasil diperbarui
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/User'
 *               example:
 *                 message: "Profil berhasil diperbarui"
 *                 data:
 *                   id: "123"
 *                   username: "john_doe"
 *                   email: "john@example.com"
 *                   role: "user"
 *                   fullName: "Jane Doe"
 *                   address: "456 Another St"
 *                   age: 28
 *                   gender: "Female"
 *                   createdAt: "2023-01-01T00:00:00.000Z"
 *                   updatedAt: "2023-02-01T00:00:00.000Z"
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: User tidak ditemukan
 */
export const updateProfile = async (req, res) => {
  try {
    const userId = req.userId; // ID user yang sedang login
    const { password, fullName, address, age, gender } = req.body;

    const currentUser = await User.findByPk(userId);
    if (!currentUser) {
      return res.status(404).json({ message: "User tidak ditemukan" });
    }

    // Update fields
    if (password) {
      const hashed = await bcrypt.hash(password, 10);
      currentUser.password = hashed;
    }
    if (fullName !== undefined) currentUser.fullName = fullName;
    if (address !== undefined) currentUser.address = address;
    if (age !== undefined) currentUser.age = age;
    if (gender !== undefined) currentUser.gender = gender;

    // role tidak boleh diubah

    await currentUser.save();

    return res.json({
      message: "Profil berhasil diperbarui",
      data: {
        id: currentUser.id,
        username: currentUser.username,
        email: currentUser.email,
        role: currentUser.role, // tetap
        fullName: currentUser.fullName,
        address: currentUser.address,
        age: currentUser.age,
        gender: currentUser.gender,
        createdAt: currentUser.createdAt,
        updatedAt: currentUser.updatedAt,
      },
    });
  } catch (error) {
    logger.error(`Error in updateProfile: ${error.message}`);
    return res.status(500).json({ message: "Internal server error" });
  }
};
======== FILE: ./src/middlewares/adminMiddleware.js ========
import logger from "./loggingMiddleware.js";

const adminMiddleware = (req, res, next) => {
  if (req.userRole !== "admin" && req.userRole !== "owner") {
    logger.warn(
      `Access denied for user ID: ${req.userId} with role: ${req.userRole}`
    );
    return res.status(403).json({ message: "Access denied" });
  }
  next();
};

export default adminMiddleware;
======== FILE: ./src/middlewares/authMiddleware.js ========
import { verifyAccessToken } from "../utils/token.js";
import logger from "./loggingMiddleware.js";

export default function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    logger.warn('No token provided');
    return res.status(401).json({ message: "No token provided" });
  }

  const token = authHeader.split(" ")[1];
  if (!token) {
    logger.warn('Invalid token format');
    return res.status(401).json({ message: "Invalid token format" });
  }

  try {
    const decoded = verifyAccessToken(token);
    req.userId = decoded.id;
    req.userRole = decoded.role;
    next();
  } catch (error) {
    logger.warn('Token invalid or expired');
    return res.status(401).json({ message: "Token invalid or expired" });
  }
}
======== FILE: ./src/middlewares/loggingMiddleware.js ========
import winston from 'winston';
import path from 'path';
import fs from 'fs';

// Pastikan direktori logs ada
const logDir = 'logs';
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir);
}

// Definisikan format log
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(info => `${info.timestamp} [${info.level.toUpperCase()}]: ${info.message}`)
);

// Buat instance logger
const logger = winston.createLogger({
  level: 'info',
  format: logFormat,
  transports: [
    // Tulis semua log dengan level `info` dan di bawahnya ke `combined.log`
    new winston.transports.File({ filename: path.join(logDir, 'combined.log') }),
    // Tulis semua log dengan level `error` dan di bawahnya ke `error.log`
    new winston.transports.File({ filename: path.join(logDir, 'error.log'), level: 'error' }),
  ],
});

// Jika bukan produksi, log juga ke console
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}

export default logger;
======== FILE: ./src/middlewares/ownerMiddleware.js ========
import logger from "./loggingMiddleware.js";

export default function ownerMiddleware(req, res, next) {
  if (req.userRole !== "owner") {
    logger.warn(`User ${req.userId} mencoba mengakses rute owner`);
    return res.status(403).json({ message: "Forbidden: Owner only" });
  }
  next();
}
======== FILE: ./src/middlewares/rateLimiter.js ========
import rateLimit from 'express-rate-limit';

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 menit
  max: 10, // Batasi setiap IP ke 10 permintaan per windowMs
  message: 'Terlalu banyak percobaan login dari IP ini, silakan coba lagi setelah 15 menit',
  standardHeaders: true, // Mengembalikan informasi rate limit di header `RateLimit-*`
  legacyHeaders: false, // Nonaktifkan header `X-RateLimit-*`
});

export default loginLimiter;
======== FILE: ./src/middlewares/validationMiddleware.js ========
import { validationResult } from "express-validator";

export const validationMiddleware = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  next();
};
======== FILE: ./src/migrations/20231227000000-create-user.js ========
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Users', {
      id: {
        allowNull: false,
        primaryKey: true,
        type: Sequelize.UUID,
        defaultValue: Sequelize.literal('uuid_generate_v4()'), // Menggunakan fungsi UUID dari extension
      },
      username: {
        type: Sequelize.STRING(50),
        allowNull: false,
        unique: true,
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      role: {
        type: Sequelize.ENUM('owner', 'admin', 'user'),
        allowNull: false,
        defaultValue: 'user',
      },
      fullName: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      address: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      age: {
        type: Sequelize.INTEGER,
        allowNull: true,
      },
      gender: {
        type: Sequelize.ENUM('Pria', 'Wanita'),
        allowNull: true,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('NOW()'),
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('NOW()'),
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Users');
  },
};
======== FILE: ./src/migrations/20231227000001-create-report.js ========
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Reports', {
      id: {
        allowNull: false,
        primaryKey: true,
        type: Sequelize.UUID,
        defaultValue: Sequelize.literal('uuid_generate_v4()'), // Menggunakan fungsi UUID dari extension
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false,
      },
      userId: { // Foreign key dari Users
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'Users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      validationStatus: {
        type: Sequelize.STRING, // 'hoax', 'valid', 'unknown'
        allowNull: false,
        defaultValue: 'unknown',
      },
      validationDetails: {
        type: Sequelize.TEXT,
        allowNull: true,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('NOW()'),
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('NOW()'),
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Reports');
  },
};
======== FILE: ./src/migrations/20231227000002-enable-uuid-ossp.js ========
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.sequelize.query('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";');
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.sequelize.query('DROP EXTENSION IF EXISTS "uuid-ossp";');
  },
};
======== FILE: ./src/migrations/20250101095607-add-email-to-users.js ========
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('Users', 'email', {
      type: Sequelize.STRING,
      allowNull: true, // Mengizinkan NULL
      unique: true,
      validate: {
        isEmail: true,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'email');
  }
};
======== FILE: ./src/models/index.js ========
import { Sequelize } from "sequelize";
import dotenv from "dotenv";
import logger from "../middlewares/loggingMiddleware.js";

// Import definisi model sebagai fungsi
import defineUser from "./user.js";
import defineReport from "./report.js";

dotenv.config();

// Inisialisasi Sequelize
const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASS,
  {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: "postgres",
    logging: false, // Nonaktifkan logging SQL
  }
);

// Uji koneksi ke database
sequelize.authenticate()
  .then(() => {
    logger.info("Koneksi ke database berhasil.");
  })
  .catch((err) => {
    logger.error("Koneksi ke database gagal:", err);
  });

// Definisikan model dengan memanggil fungsi definisi
const User = defineUser(sequelize);
const Report = defineReport(sequelize);

// Definisikan relasi
User.hasMany(Report, {
  foreignKey: "userId",
  as: "reports",
});

Report.belongsTo(User, {
  foreignKey: "userId",
  as: "user",
});

// Simpan ke objek db untuk ekspor
const db = {};
db.Sequelize = Sequelize;
db.sequelize = sequelize;
db.User = User;
db.Report = Report;

export { User, Report };
export default db;
======== FILE: ./src/models/report.js ========
import { DataTypes } from "sequelize";

export default (sequelize) => {
  const Report = sequelize.define("Report", {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false,
    },
    validationStatus: {
      type: DataTypes.STRING, // 'hoax', 'valid', 'unknown'
      defaultValue: "unknown",
    },
    validationDetails: {
      type: DataTypes.TEXT,
      allowNull: true,
    },
  }, {
    tableName: "Reports",
    timestamps: true,
  });

  return Report;
};
======== FILE: ./src/models/user.js ========
import { DataTypes } from "sequelize";

const User = sequelize.define(
  "User",
  {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    email: {
      // Kolom email sekarang tidak wajib
      type: DataTypes.STRING,
      allowNull: true, // Mengizinkan NULL
      unique: true,
      validate: {
        isEmail: true,
      },
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    role: {
      type: DataTypes.ENUM("admin", "owner", "user"),
      defaultValue: "user",
    },
    fullName: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    address: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    age: {
      type: DataTypes.INTEGER,
      allowNull: true,
    },
    gender: {
      type: DataTypes.STRING,
      allowNull: true,
    },
  },
  {
    tableName: "Users", // Pastikan nama tabel sesuai dengan yang digunakan di database
    timestamps: true, // Jika  menggunakan createdAt dan updatedAt
  }
);

export default User;
======== FILE: ./src/routes/authRoutes.js ========
import express from "express";
import { register, login, refresh } from "../controllers/authController.js";
import authMiddleware from "../middlewares/authMiddleware.js";
import adminMiddleware from "../middlewares/adminMiddleware.js";
import loginLimiter from "../middlewares/rateLimiter.js";

import { body } from 'express-validator';
import { validationMiddleware } from '../middlewares/validationMiddleware.js';

const router = express.Router();

/**
 * @swagger
 * tags:
 *   name: Auth
 *   description: Autentikasi dan otorisasi pengguna
 */

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Mendaftarkan pengguna baru (hanya admin/owner)
 *     tags: [Auth]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - email
 *               - password
 *             properties:
 *               username:
 *                 type: string
 *                 description: Nama pengguna
 *               email:
 *                 type: string
 *                 format: email
 *                 description: Alamat email pengguna
 *               password:
 *                 type: string
 *                 format: password
 *                 description: Kata sandi pengguna
 *               role:
 *                 type: string
 *                 enum: [admin, owner, user]
 *                 description: Peran pengguna (opsional)
 *             example:
 *               username: "john_doe"
 *               email: "john@example.com"
 *               password: "Password123!"
 *               role: "user"
 *     responses:
 *       201:
 *         description: Pengguna berhasil didaftarkan
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AuthResponse'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
router.post(
  "/register",
  authMiddleware,
  adminMiddleware,
  [
    body('username').isString().notEmpty().withMessage('Username wajib diisi dan harus berupa string'),
    body('email').isEmail().withMessage('Email harus valid'),
    body('password').isLength({ min: 6 }).withMessage('Password harus minimal 6 karakter'),
    body('role').optional().isIn(['admin', 'owner', 'user']).withMessage("Role harus 'admin', 'owner', atau 'user'"),
  ],
  validationMiddleware,
  register
);

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Masuk pengguna
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - password
 *             properties:
 *               username:
 *                 type: string
 *                 description: Nama pengguna
 *               password:
 *                 type: string
 *                 format: password
 *                 description: Kata sandi pengguna
 *             example:
 *               username: "john_doe"
 *               password: "Password123!"
 *     responses:
 *       200:
 *         description: Berhasil masuk
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/LoginResponse'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Autentikasi gagal
 */
router.post(
  "/login",
  loginLimiter, // Terapkan rate limiter pada login
  [
    body('username').isString().notEmpty().withMessage('Username wajib diisi dan harus berupa string'),
    body('password').isString().notEmpty().withMessage('Password wajib diisi dan harus berupa string'),
  ],
  validationMiddleware,
  login
);

/**
 * @swagger
 * /api/auth/refresh:
 *   post:
 *     summary: Memperbarui access token menggunakan refresh token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *                 description: Refresh token yang valid
 *             example:
 *               refreshToken: "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4="
 *     responses:
 *       200:
 *         description: Token berhasil diperbarui
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RefreshResponse'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Refresh token tidak valid
 */
router.post(
  "/refresh",
  [
    body('refreshToken').isString().notEmpty().withMessage('Refresh token wajib diisi dan harus berupa string'),
  ],
  validationMiddleware,
  refresh
);

export default router;
======== FILE: ./src/routes/reportRoutes.js ========
import express from "express";
import { createReport, getAllReports, getReportById, deleteReport } from "../controllers/reportController.js";
import authMiddleware from "../middlewares/authMiddleware.js";

import { body, param } from 'express-validator';
import { validationMiddleware } from '../middlewares/validationMiddleware.js';

const router = express.Router();

/**
 * @swagger
 * tags:
 *   name: Reports
 *   description: Pengelolaan laporan
 */

/**
 * @swagger
 * /api/reports:
 *   post:
 *     summary: Membuat laporan baru
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - content
 *               - link
 *             properties:
 *               title:
 *                 type: string
 *                 description: Judul laporan
 *               content:
 *                 type: string
 *                 description: Isi laporan
 *               link:
 *                 type: string
 *                 format: uri
 *                 description: URL sumber terkait laporan
 *             example:
 *               title: "Hoax Example"
 *               content: "This is an example of a hoax report."
 *               link: "https://example.com/hoax"
 *     responses:
 *       201:
 *         description: Laporan berhasil dibuat
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Report'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
router.post(
  "/",
  authMiddleware,
  [
    body('title').isString().notEmpty().withMessage('Title wajib diisi dan harus berupa string'),
    body('content').isString().notEmpty().withMessage('Content wajib diisi dan harus berupa string'),
    body('link').isURL().withMessage('Link harus berupa URL yang valid'),
  ],
  validationMiddleware,
  createReport
);

/**
 * @swagger
 * /api/reports:
 *   get:
 *     summary: Mengambil semua laporan
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Daftar semua laporan
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Report'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
router.get(
  "/",
  authMiddleware,
  getAllReports
);

/**
 * @swagger
 * /api/reports/{reportId}:
 *   get:
 *     summary: Mengambil laporan berdasarkan ID
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: reportId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik laporan
 *     responses:
 *       200:
 *         description: Informasi laporan
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Report'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Laporan tidak ditemukan
 */
router.get(
  "/:reportId",
  authMiddleware,
  [
    param('reportId').isString().notEmpty().withMessage('ID laporan harus diisi dan berupa string'),
  ],
  validationMiddleware,
  getReportById
);

/**
 * @swagger
 * /api/reports/{reportId}:
 *   delete:
 *     summary: Menghapus laporan berdasarkan ID
 *     tags: [Reports]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: reportId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik laporan
 *     responses:
 *       200:
 *         description: Laporan berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: Pesan status
 *               example:
 *                 message: "Report berhasil dihapus"
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Laporan tidak ditemukan
 */
router.delete(
  "/:reportId",
  authMiddleware,
  [
    param('reportId').isString().notEmpty().withMessage('ID laporan harus diisi dan berupa string'),
  ],
  validationMiddleware,
  deleteReport
);

export default router;
======== FILE: ./src/routes/userRoutes.js ========
import express from "express";
import * as userController from "../controllers/userController.js";
import authMiddleware from "../middlewares/authMiddleware.js";
import adminMiddleware from "../middlewares/adminMiddleware.js";
import ownerMiddleware from "../middlewares/ownerMiddleware.js";
import { body, param } from 'express-validator';
import { validationMiddleware } from '../middlewares/validationMiddleware.js';

const router = express.Router();

/**
 * @swagger
 * tags:
 *   name: Users
 *   description: Pengelolaan pengguna
 */

/**
 * @swagger
 * /api/users:
 *   get:
 *     summary: Mengambil semua pengguna (admin/owner)
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Daftar semua pengguna
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/User'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 */
router.get("/", authMiddleware, adminMiddleware, userController.getAllUsers);

/**
 * @swagger
 * /api/users/{userId}:
 *   get:
 *     summary: Mengambil pengguna berdasarkan ID
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik pengguna
 *     responses:
 *       200:
 *         description: Informasi pengguna
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Pengguna tidak ditemukan
 */
router.get(
  "/:userId",
  authMiddleware,
  [
    param('userId').isString().notEmpty().withMessage('ID pengguna harus diisi dan berupa string'),
  ],
  validationMiddleware,
  userController.getUserById
);

/**
 * @swagger
 * /api/users/{userId}:
 *   delete:
 *     summary: Menghapus pengguna (role=user) oleh admin/owner
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik pengguna
 *     responses:
 *       200:
 *         description: Pengguna berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: Pesan status
 *               example:
 *                 message: "User (role=user) berhasil dihapus"
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: User tidak ditemukan
 */
router.delete(
  "/:userId",
  authMiddleware,
  adminMiddleware,
  [
    param('userId').isString().notEmpty().withMessage('ID pengguna harus diisi dan berupa string'),
  ],
  validationMiddleware,
  userController.deleteUser
);

/**
 * @swagger
 * /api/users/admin/{adminId}:
 *   delete:
 *     summary: Menghapus admin (hanya oleh owner)
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: adminId
 *         required: true
 *         schema:
 *           type: string
 *         description: ID unik admin
 *     responses:
 *       200:
 *         description: Admin berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: Pesan status
 *               example:
 *                 message: "Admin berhasil dihapus"
 *       401:
 *         description: Tidak terautentikasi
 *       403:
 *         description: Akses ditolak
 *       404:
 *         description: Admin tidak ditemukan
 */
router.delete(
  "/admin/:adminId",
  authMiddleware,
  ownerMiddleware,
  [
    param('adminId').isString().notEmpty().withMessage('ID admin harus diisi dan berupa string'),
  ],
  validationMiddleware,
  userController.deleteAdmin
);

/**
 * @swagger
 * /api/users/profile:
 *   put:
 *     summary: Memperbarui profil pengguna (update diri sendiri)
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               password:
 *                 type: string
 *                 format: password
 *                 description: Kata sandi baru (opsional)
 *               fullName:
 *                 type: string
 *                 description: Nama lengkap baru (opsional)
 *               address:
 *                 type: string
 *                 description: Alamat baru (opsional)
 *               age:
 *                 type: integer
 *                 description: Usia baru (opsional)
 *               gender:
 *                 type: string
 *                 description: Jenis kelamin baru (opsional)
 *             example:
 *               password: "NewPassword123!"
 *               fullName: "Jane Doe"
 *               address: "456 Another St"
 *               age: 28
 *               gender: "Female"
 *     responses:
 *       200:
 *         description: Profil berhasil diperbarui
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/User'
 *               example:
 *                 message: "Profil berhasil diperbarui"
 *                 data:
 *                   id: "123"
 *                   username: "john_doe"
 *                   email: "john@example.com"
 *                   role: "user"
 *                   fullName: "Jane Doe"
 *                   address: "456 Another St"
 *                   age: 28
 *                   gender: "Female"
 *                   createdAt: "2023-01-01T00:00:00.000Z"
 *                   updatedAt: "2023-02-01T00:00:00.000Z"
 *       400:
 *         description: Permintaan tidak valid
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationError'
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: User tidak ditemukan
 */
router.put(
  "/profile",
  authMiddleware,
  [
    body('password').optional().isLength({ min: 6 }).withMessage('Password harus minimal 6 karakter'),
    body('fullName').optional().isString().withMessage('FullName harus berupa string'),
    body('address').optional().isString().withMessage('Address harus berupa string'),
    body('age').optional().isInt({ min: 0 }).withMessage('Age harus berupa integer positif'),
    body('gender').optional().isString().withMessage('Gender harus berupa string'),
  ],
  validationMiddleware,
  userController.updateProfile
);

export default router;
======== FILE: ./src/server.js ========
import dotenv from "dotenv";
dotenv.config();

import app from "./app.js";
import db from "./models/index.js";
import { createStarterAccounts } from "./utils/createStarterAccounts.js";
import logger from "./middlewares/loggingMiddleware.js";

const PORT = process.env.PORT || 3000;

db.sequelize
  .sync()
  .then(async () => {
    logger.info("Database berhasil disinkronisasi!");

    await createStarterAccounts();

    app.listen(PORT, () => {
      logger.info(`Server berjalan di port ${PORT}`);
      logger.info(`Swagger docs available at http://localhost:${PORT}/api-docs`);
    });
  })
  .catch((err) => {
    logger.error("Error sinkronisasi database:", err);
  });
======== FILE: ./src/services/authService.js ========
import bcrypt from "bcrypt";
import db from "../models/index.js";
import {
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
} from "../utils/token.js";
import logger from "../middlewares/loggingMiddleware.js";

const User = db.User;

export const registerUser = async ({ username, password, role }) => {
  // Validasi role
  if (role && !["admin", "user"].includes(role)) {
    logger.warn(`Role tidak valid: ${role}`);
    throw { status: 400, message: "Role harus 'admin' atau 'user'" };
  }

  // Cek keberadaan user
  const existingUser = await User.findOne({ where: { username } });
  if (existingUser) {
    logger.warn(
      `Percobaan registrasi dengan username yang sudah ada: ${username}`
    );
    throw { status: 400, message: "Username sudah ada" };
  }

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10);

  // Buat user baru
  const newUser = await User.create({
    username,
    password: hashedPassword,
    role: role || "user",
  });

  logger.info(`User baru terdaftar: ${username} dengan role ${newUser.role}`);

  return {
    id: newUser.id,
    username: newUser.username,
    role: newUser.role,
  };
};

export const loginUser = async (loginData) => {
  const { username, password } = loginData;
  const user = await db.User.findOne({ where: { username } });

  if (!user) {
    throw { status: 401, message: "Username atau password salah" };
  }

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) {
    throw { status: 401, message: "Username atau password salah" };
  }

  const accessToken = generateAccessToken({ id: user.id, role: user.role });
  const refreshToken = generateRefreshToken({ id: user.id, role: user.role });

  return {
    accessToken,
    refreshToken,
    user: { id: user.id, username: user.username, role: user.role },
  };
};

export const refreshAccessToken = async (refreshToken) => {
  if (!refreshToken) {
    logger.warn(`Refresh token tidak ada dalam permintaan`);
    throw { status: 400, message: "Refresh token diperlukan" };
  }

  let decoded;
  try {
    decoded = verifyRefreshToken(refreshToken);
  } catch (err) {
    logger.warn(`Refresh token tidak valid`);
    throw { status: 401, message: "Refresh token tidak valid" };
  }

  const newAccessToken = generateAccessToken({
    id: decoded.id,
    role: decoded.role,
  });

  logger.info(`Access token diperbarui untuk user ID: ${decoded.id}`);

  return { accessToken: newAccessToken };
};
======== FILE: ./src/services/hoaxChecker.js ========
import dotenv from "dotenv";
import { GoogleGenerativeAI } from "@google/generative-ai";
import logger from "../middlewares/loggingMiddleware.js";

dotenv.config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

/**
 * Memanggil Gemini 1.5 Flash (multi-bahasa, utamanya Indonesia)
 * untuk menilai statement,
 * lalu beri output "Hoaks"/"Asli", 1 kalimat penjelasan singkat, dan link.
 *
 * @param {string} content - Pernyataan pengguna
 * @param {string} link - Link (opsional) yang diberikan pengguna
 * @returns {Object} { validationStatus, validationDetails }
 *    - validationStatus: "hoax" atau "valid"
 *    - validationDetails: JSON string, isinya { gemini: { output, judgement, explanation, link } }
 */
export async function checkHoax(content, link) {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const promptText = `
Kamu adalah pendeteksi hoaks berkemampuan multi-bahasa (terutama Indonesia).
Pengguna mengirimkan pernyataan dan link (jika ada).
Tugasmu:
1. Tentukan apakah pernyataan itu "Hoaks" atau "Asli" (gunakan bahasa Indonesia).
2. Berikan penjelasan singkat (maksimal 2 kalimat).
3. Sertakan sumber berita terkait di baris terakhir. Jika sumber tidak ada atau kosong, tetap beri baris terakhir kosong.

Format output:
Hoaks / Asli (hanya salah satu)
[Penjelasan singkat 1 atau 2 kalimat]
[sumber berita terkait]

Pernyataan: "${content}"
Link: "${link || ""}"

Pastikan HANYA menampilkan tiga baris tersebut.
    `;

    const prompt = [{ text: promptText }];
    const result = await model.generateContent(prompt);

    // result.response = ReadableStream
    const response = await result.response;
    const textOutput = response.text(); // string

    if (!textOutput) {
      logger.error("Gemini response empty or error.");
      return {
        validationStatus: "unknown",
        validationDetails: "Gemini returned no output",
      };
    }

    // Tampilkan di console untuk debug
    logger.info("Gemini raw output:\n" + textOutput.trim());

    //
    // Ekstrak hasil:
    // Harapan 3 baris, misalnya:
    // Hoaks
    // Ini penjelasan singkat...
    // https://some-link.com
    //
    const lines = textOutput
      .trim()
      .split("\n")
      .map((l) => l.trim());
    // lines[0] => "Hoaks" atau "Asli"
    // lines[1] => penjelasan singkat
    // lines[2] => link

    if (lines.length < 2) {
      // fallback
      logger.warn(
        "Gemini output tidak dalam format 3 baris yang diharapkan. Semua = ",
        lines
      );
      return {
        validationStatus: "unknown",
        validationDetails: `Gemini uncertain: ${textOutput}`,
      };
    }

    const judgement = lines[0];
    const explanation = lines[1] || "";
    const userLink = lines[2] || "";

    let validationStatus = "unknown";
    if (judgement.toLowerCase().includes("hoaks")) {
      validationStatus = "hoax";
    } else if (judgement.toLowerCase().includes("asli")) {
      validationStatus = "valid";
    } else {
      // fallback
      logger.warn("Gemini tidak mengeluarkan 'Hoaks' atau 'Asli'.");
      validationStatus = "unknown";
    }

    // Buat detail JSON
    const validationDetails = JSON.stringify({
      gemini: {
        output: textOutput, // teks mentah
        judgement, // baris 0
        explanation, // baris 1
        link: userLink, // baris 2
      },
    });

    return {
      validationStatus,
      validationDetails,
    };
  } catch (error) {
    logger.error("Error dalam checkHoax (Gemini): " + error.message);
    return {
      validationStatus: "unknown",
      validationDetails: "Error checking hoax via Gemini",
    };
  }
}
======== FILE: ./src/swagger.js ========
// src/swagger.js

import swaggerJSDoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';

// Definisikan opsi untuk swaggerJSDoc
const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Hamlet Information System API',
      version: '1.0.0',
      description: 'API untuk mengelola informasi di Hamlet Information System.',
    },
    servers: [
      {
        url: 'http://localhost:3000', // Ganti dengan URL server Anda
      },
    ],
    components: {
      securitySchemes: {
        BearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'ID unik pengguna',
            },
            username: {
              type: 'string',
              description: 'Nama pengguna',
            },
            email: {
              type: 'string',
              format: 'email',
              description: 'Alamat email pengguna',
            },
            role: {
              type: 'string',
              enum: ['admin', 'owner', 'user'],
              description: 'Peran pengguna',
            },
            fullName: {
              type: 'string',
              description: 'Nama lengkap pengguna',
            },
            address: {
              type: 'string',
              description: 'Alamat pengguna',
            },
            age: {
              type: 'integer',
              description: 'Usia pengguna',
            },
            gender: {
              type: 'string',
              description: 'Jenis kelamin pengguna',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Waktu pembuatan pengguna',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Waktu pembaruan terakhir pengguna',
            },
          },
          example: {
            id: "123",
            username: "john_doe",
            email: "john@example.com",
            role: "user",
            fullName: "John Doe",
            address: "123 Main St",
            age: 30,
            gender: "Male",
            createdAt: "2023-01-01T00:00:00.000Z",
            updatedAt: "2023-01-01T00:00:00.000Z",
          },
        },
        Report: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'ID unik laporan',
            },
            title: {
              type: 'string',
              description: 'Judul laporan',
            },
            content: {
              type: 'string',
              description: 'Isi laporan',
            },
            link: {
              type: 'string',
              format: 'uri',
              description: 'URL sumber terkait laporan',
            },
            userId: {
              type: 'string',
              description: 'ID pengguna yang membuat laporan',
            },
            validationStatus: {
              type: 'string',
              description: 'Status validasi (Valid/Invalid)',
            },
            validationDetails: {
              type: 'string',
              description: 'Detail validasi',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Waktu pembuatan laporan',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Waktu pembaruan terakhir laporan',
            },
          },
          example: {
            id: "456",
            title: "Hoax Example",
            content: "This is an example of a hoax report.",
            link: "https://example.com/hoax",
            userId: "123",
            validationStatus: "Valid",
            validationDetails: "Verified by Hugging Face model.",
            createdAt: "2023-01-01T00:00:00.000Z",
            updatedAt: "2023-01-01T00:00:00.000Z",
          },
        },
        HoaxCheck: {
          type: 'object',
          properties: {
            text: {
              type: 'string',
              description: 'Teks yang akan diperiksa',
            },
            result: {
              type: 'string',
              description: 'Hasil pemeriksaan (Hoax/Bukan Hoax)',
            },
          },
          example: {
            text: "Ini adalah contoh teks hoax.",
            result: "Hoax",
          },
        },
        AuthResponse: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: 'Pesan status',
            },
            user: {
              $ref: '#/components/schemas/User',
            },
            access_token: {
              type: 'string',
              description: 'Token akses JWT',
            },
            refresh_token: {
              type: 'string',
              description: 'Token refresh JWT',
            },
          },
          example: {
            message: "User berhasil dibuat",
            user: {
              id: "123",
              username: "john_doe",
              email: "john@example.com",
              role: "user",
              fullName: "John Doe",
              address: "123 Main St",
              age: 30,
              gender: "Male",
              createdAt: "2023-01-01T00:00:00.000Z",
              updatedAt: "2023-01-01T00:00:00.000Z",
            },
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
            refresh_token: "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4=",
          },
        },
        LoginResponse: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: 'Pesan status',
            },
            access_token: {
              type: 'string',
              description: 'Token akses JWT',
            },
            refresh_token: {
              type: 'string',
              description: 'Token refresh JWT',
            },
          },
          example: {
            message: "Login berhasil",
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
            refresh_token: "dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4=",
          },
        },
        RefreshResponse: {
          type: 'object',
          properties: {
            access_token: {
              type: 'string',
              description: 'Token akses JWT baru',
            },
          },
          example: {
            access_token: "newAccessTokenExample",
          },
        },
      },
    },
    security: [
      {
        BearerAuth: [],
      },
    ],
  },
  // Path ke file yang berisi anotasi Swagger (menggunakan JSDoc)
  apis: ['./src/routes/*.js', './src/controllers/*.js'],
};

// Inisialisasi swaggerJSDoc
const swaggerSpec = swaggerJSDoc(options);

// Fungsi untuk mengatur Swagger
const setupSwagger = (app) => {
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, { explorer: true }));
};

export default setupSwagger;
======== FILE: ./src/tests/integration/authRoutes.test.js ========
// Mock middleware dengan benar (default exports)
jest.mock("../../middlewares/authMiddleware.js", () => ({
  default: (req, res, next) => next(),
}));

jest.mock("../../middlewares/adminMiddleware.js", () => ({
  default: (req, res, next) => next(),
}));

jest.mock("../../middlewares/rateLimiter.js", () => ({
  default: (req, res, next) => next(),
}));

jest.mock("../../middlewares/validationMiddleware.js", () => ({
  default: (req, res, next) => next(),
}));

// Mock controller functions
jest.mock("../../controllers/authController.js", () => ({
  register: jest.fn(),
  login: jest.fn(),
  refresh: jest.fn(),
}));

// Mock dependencies
jest.mock("../../models/index.js");
jest.mock("../../utils/token.js");

// Sekarang impor setelah semua mocking
import request from "supertest";
import app from "../../app.js";
import db from "../../models/index.js";
import bcrypt from "bcrypt";
import {
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
} from "../../utils/token.js";
import { register, login, refresh } from "../../controllers/authController.js";

describe("Auth Routes", () => {
  let server;
  let User;

  beforeAll(() => {
    User = db.User;
    server = app.listen(4000); // Menggunakan port yang berbeda untuk testing
  });

  afterAll((done) => {
    server.close(done);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("POST /api/auth/register", () => {
    it("harus berhasil mendaftarkan user baru", async () => {
      const userData = {
        username: "newuser",
        password: "password123",
        role: "user",
      };
      User.findOne.mockResolvedValue(null);
      bcrypt.hash = jest.fn().mockResolvedValue("hashedPassword");
      User.create.mockResolvedValue({
        id: 1,
        username: "newuser",
        role: "user",
      });

      // Mock implementasi register function
      register.mockImplementation((req, res) => {
        res.status(201).json({
          message: "User berhasil dibuat",
          data: { id: 1, username: "newuser", role: "user" },
        });
      });

      const res = await request(app).post("/api/auth/register").send(userData);

      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty("message", "User berhasil dibuat");
      expect(res.body.data).toHaveProperty("username", "newuser");
      expect(res.body.data).toHaveProperty("role", "user");
      expect(register).toHaveBeenCalled();
    });

    it("harus gagal mendaftarkan user dengan username yang sudah ada", async () => {
      const userData = {
        username: "existinguser",
        password: "password123",
        role: "user",
      };
      User.findOne.mockResolvedValue({ username: "existinguser" });

      // Mock implementasi register function untuk error
      register.mockImplementation((req, res) => {
        res.status(400).json({ message: "Username sudah ada" });
      });

      const res = await request(app).post("/api/auth/register").send(userData);

      expect(res.statusCode).toEqual(400);
      expect(res.body).toHaveProperty("message", "Username sudah ada");
      expect(register).toHaveBeenCalled();
    });
  });

  describe("POST /api/auth/login", () => {
    it("harus berhasil login user", async () => {
      const loginData = { username: "validuser", password: "password123" };
      const user = {
        id: 1,
        username: "validuser",
        password: "hashedPassword",
        role: "user",
      };
      User.findOne.mockResolvedValue(user);
      bcrypt.compare = jest.fn().mockResolvedValue(true);
      generateAccessToken.mockReturnValue("accessToken");
      generateRefreshToken.mockReturnValue("refreshToken");

      // Mock implementasi login function
      login.mockImplementation((req, res) => {
        res.status(200).json({
          message: "Login berhasil",
          accessToken: "accessToken",
          refreshToken: "refreshToken",
          user: { id: 1, username: "validuser", role: "user" },
        });
      });

      const res = await request(app).post("/api/auth/login").send(loginData);

      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty("message", "Login berhasil");
      expect(res.body).toHaveProperty("accessToken", "accessToken");
      expect(res.body).toHaveProperty("refreshToken", "refreshToken");
      expect(res.body.user).toHaveProperty("username", "validuser");
      expect(res.body.user).toHaveProperty("role", "user");
      expect(login).toHaveBeenCalled();
    });

    it("harus gagal login dengan kredensial yang tidak valid", async () => {
      const loginData = { username: "invaliduser", password: "wrongpassword" };
      User.findOne.mockResolvedValue(null);

      // Mock implementasi login function untuk error
      login.mockImplementation((req, res) => {
        res.status(401).json({ message: "Username atau password salah" });
      });

      const res = await request(app).post("/api/auth/login").send(loginData);

      expect(res.statusCode).toEqual(401);
      expect(res.body).toHaveProperty(
        "message",
        "Username atau password salah"
      );
      expect(login).toHaveBeenCalled();
    });
  });

  describe("POST /api/auth/refresh", () => {
    it("harus berhasil memperbarui access token", async () => {
      const refreshData = { refreshToken: "validRefreshToken" };
      const decoded = { id: 1, role: "user" };
      verifyRefreshToken.mockReturnValue(decoded);
      generateAccessToken.mockReturnValue("newAccessToken");

      // Mock implementasi refresh function
      refresh.mockImplementation((req, res) => {
        res.status(200).json({ accessToken: "newAccessToken" });
      });

      const res = await request(app)
        .post("/api/auth/refresh")
        .send(refreshData);

      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty("accessToken", "newAccessToken");
      expect(refresh).toHaveBeenCalled();
    });

    it("harus gagal memperbarui token jika refresh token tidak ada", async () => {
      const refreshData = {};

      // Mock implementasi refresh function untuk error
      refresh.mockImplementation((req, res) => {
        res.status(400).json({
          errors: [
            { path: "refreshToken", msg: "Invalid value" },
            {
              path: "refreshToken",
              msg: "Refresh token wajib diisi dan harus berupa string",
            },
          ],
        });
      });

      const res = await request(app)
        .post("/api/auth/refresh")
        .send(refreshData);

      expect(res.statusCode).toEqual(400);
      expect(res.body).toHaveProperty("errors");
      expect(res.body.errors).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            path: "refreshToken",
            msg: "Invalid value",
          }),
          expect.objectContaining({
            path: "refreshToken",
            msg: "Refresh token wajib diisi dan harus berupa string",
          }),
        ])
      );
      expect(refresh).toHaveBeenCalled();
    });

    it("harus gagal memperbarui token jika refresh token tidak valid", async () => {
      const refreshData = { refreshToken: "invalidRefreshToken" };
      verifyRefreshToken.mockImplementation(() => {
        throw new Error("Invalid token");
      });

      // Mock implementasi refresh function untuk error
      refresh.mockImplementation((req, res) => {
        res.status(401).json({ message: "Refresh token tidak valid" });
      });

      const res = await request(app)
        .post("/api/auth/refresh")
        .send(refreshData);

      expect(res.statusCode).toEqual(401);
      expect(res.body).toHaveProperty("message", "Refresh token tidak valid");
      expect(refresh).toHaveBeenCalled();
    });
  });
});
======== FILE: ./src/tests/unit/authService.test.js ========
import { registerUser, loginUser, refreshAccessToken } from "../../services/authService.js";
import db from "../../models/index.js";
import bcrypt from "bcrypt";
import { generateAccessToken, generateRefreshToken, verifyRefreshToken } from "../../utils/token.js";

jest.mock("../../models/index.js");
jest.mock("../../utils/token.js");

describe("Auth Service", () => {
  let User;

  beforeAll(() => {
    User = db.User;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("registerUser", () => {
    it("harus berhasil mendaftarkan user baru", async () => {
      const userData = { username: "newuser", password: "password123", role: "user" };
      User.findOne.mockResolvedValue(null);
      bcrypt.hash = jest.fn().mockResolvedValue("hashedPassword");
      User.create.mockResolvedValue({
        id: 1,
        username: "newuser",
        role: "user",
      });

      const result = await registerUser(userData);

      expect(User.findOne).toHaveBeenCalledWith({ where: { username: "newuser" } });
      expect(bcrypt.hash).toHaveBeenCalledWith("password123", 10);
      expect(User.create).toHaveBeenCalledWith({
        username: "newuser",
        password: "hashedPassword",
        role: "user",
      });
      expect(result).toEqual({
        id: 1,
        username: "newuser",
        role: "user",
      });
    });

    it("harus melempar error jika username sudah ada", async () => {
      const userData = { username: "existinguser", password: "password123", role: "user" };
      User.findOne.mockResolvedValue({ username: "existinguser" });

      await expect(registerUser(userData)).rejects.toEqual({
        status: 400,
        message: "Username sudah ada",
      });
    });

    it("harus melempar error jika role tidak valid", async () => {
      const userData = { username: "user", password: "password123", role: "invalidRole" };

      await expect(registerUser(userData)).rejects.toEqual({
        status: 400,
        message: "Role harus 'admin' atau 'user'",
      });
    });
  });

  describe("loginUser", () => {
    it("harus berhasil login user", async () => {
      const loginData = { username: "validuser", password: "password123" };
      const user = {
        id: 1,
        username: "validuser",
        password: "hashedPassword",
        role: "user",
      };
      User.findOne.mockResolvedValue(user);
      bcrypt.compare = jest.fn().mockResolvedValue(true);
      generateAccessToken.mockReturnValue("accessToken");
      generateRefreshToken.mockReturnValue("refreshToken");

      const result = await loginUser(loginData);

      expect(User.findOne).toHaveBeenCalledWith({ where: { username: "validuser" } });
      expect(bcrypt.compare).toHaveBeenCalledWith("password123", "hashedPassword");
      expect(generateAccessToken).toHaveBeenCalledWith({ id: 1, role: "user" });
      expect(generateRefreshToken).toHaveBeenCalledWith({ id: 1, role: "user" });
      expect(result).toEqual({
        accessToken: "accessToken",
        refreshToken: "refreshToken",
        user: {
          id: 1,
          username: "validuser",
          role: "user",
        },
      });
    });

    it("harus melempar error jika user tidak ada", async () => {
      const loginData = { username: "nonexistent", password: "password123" };
      User.findOne.mockResolvedValue(null);

      await expect(loginUser(loginData)).rejects.toEqual({
        status: 401,
        message: "Username atau password salah",
      });
    });

    it("harus melempar error jika password tidak cocok", async () => {
      const loginData = { username: "validuser", password: "wrongpassword" };
      const user = {
        id: 1,
        username: "validuser",
        password: "hashedPassword",
        role: "user",
      };
      User.findOne.mockResolvedValue(user);
      bcrypt.compare = jest.fn().mockResolvedValue(false);

      await expect(loginUser(loginData)).rejects.toEqual({
        status: 401,
        message: "Username atau password salah",
      });
    });
  });

  describe("refreshAccessToken", () => {
    it("harus berhasil memperbarui access token", async () => {
      const refreshToken = "validRefreshToken";
      const decoded = { id: 1, role: "user" };
      verifyRefreshToken.mockReturnValue(decoded);
      generateAccessToken.mockReturnValue("newAccessToken");

      const result = await refreshAccessToken(refreshToken);

      expect(verifyRefreshToken).toHaveBeenCalledWith("validRefreshToken");
      expect(generateAccessToken).toHaveBeenCalledWith({ id: 1, role: "user" });
      expect(result).toEqual({ accessToken: "newAccessToken" });
    });

    it("harus melempar error jika refresh token tidak ada", async () => {
      await expect(refreshAccessToken(null)).rejects.toEqual({
        status: 400,
        message: "Refresh token diperlukan",
      });
    });

    it("harus melempar error jika refresh token tidak valid", async () => {
      const refreshToken = "invalidRefreshToken";
      verifyRefreshToken.mockImplementation(() => { throw new Error("Invalid token"); });

      await expect(refreshAccessToken(refreshToken)).rejects.toEqual({
        status: 401,
        message: "Refresh token tidak valid",
      });
    });
  });
});
======== FILE: ./src/tests/unit/token.test.js ========
// Mock seluruh module 'jsonwebtoken'
jest.mock("jsonwebtoken");

// Mock 'encrypt' dan 'decrypt' dari 'encryption.js' sebagai jest.fn()
jest.mock("../../utils/encryption.js", () => ({
  encrypt: jest.fn(),
  decrypt: jest.fn(),
}));

// Sekarang impor setelah mocking
import {
  generateAccessToken,
  generateRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
} from "../../utils/token.js";
import jwt from "jsonwebtoken";
import { encrypt, decrypt } from "../../utils/encryption.js";

describe("Token Utilities", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("generateAccessToken", () => {
    it("harus menghasilkan access token dengan payload yang benar", () => {
      const payload = { id: "user123", role: "user" };
      jwt.sign.mockReturnValue("accessTokenMock");
      encrypt.mockReturnValue("encryptedAccessTokenMock");

      const token = generateAccessToken(payload);

      expect(jwt.sign).toHaveBeenCalledWith(payload, process.env.JWT_SECRET, {
        expiresIn: "1d",
      });
      expect(encrypt).toHaveBeenCalledWith("accessTokenMock");
      expect(token).toBe("encryptedAccessTokenMock");
    });
  });

  describe("generateRefreshToken", () => {
    it("harus menghasilkan refresh token dengan payload yang benar", () => {
      const payload = { id: "user123", role: "user" };
      jwt.sign.mockReturnValue("refreshTokenMock");
      encrypt.mockReturnValue("encryptedRefreshTokenMock");

      const token = generateRefreshToken(payload);

      expect(jwt.sign).toHaveBeenCalledWith(
        payload,
        process.env.JWT_REFRESH_SECRET,
        { expiresIn: "7d" }
      );
      expect(encrypt).toHaveBeenCalledWith("refreshTokenMock");
      expect(token).toBe("encryptedRefreshTokenMock");
    });
  });

  describe("verifyAccessToken", () => {
    it("harus memverifikasi access token dan mengembalikan payload yang didekode", () => {
      const encryptedToken = "encryptedAccessTokenMock";
      const decryptedToken = "accessTokenMock";
      const decoded = { id: "user123", role: "user" };

      decrypt.mockReturnValue(decryptedToken);
      jwt.verify.mockReturnValue(decoded);

      const result = verifyAccessToken(encryptedToken);

      expect(decrypt).toHaveBeenCalledWith(encryptedToken);
      expect(jwt.verify).toHaveBeenCalledWith(
        decryptedToken,
        process.env.JWT_SECRET
      );
      expect(result).toEqual(decoded);
    });

    it("harus melempar error jika access token tidak valid", () => {
      const encryptedToken = "invalidEncryptedAccessToken";
      const decryptedToken = "invalidAccessTokenMock";

      decrypt.mockReturnValue(decryptedToken);
      jwt.verify.mockImplementation(() => {
        throw new Error("Invalid token");
      });

      expect(() => verifyAccessToken(encryptedToken)).toThrow("Invalid token");
      expect(decrypt).toHaveBeenCalledWith(encryptedToken);
      expect(jwt.verify).toHaveBeenCalledWith(
        decryptedToken,
        process.env.JWT_SECRET
      );
    });
  });

  describe("verifyRefreshToken", () => {
    it("harus memverifikasi refresh token dan mengembalikan payload yang didekode", () => {
      const encryptedToken = "encryptedRefreshTokenMock";
      const decryptedToken = "refreshTokenMock";
      const decoded = { id: "user123", role: "user" };

      decrypt.mockReturnValue(decryptedToken);
      jwt.verify.mockReturnValue(decoded);

      const result = verifyRefreshToken(encryptedToken);

      expect(decrypt).toHaveBeenCalledWith(encryptedToken);
      expect(jwt.verify).toHaveBeenCalledWith(
        decryptedToken,
        process.env.JWT_REFRESH_SECRET
      );
      expect(result).toEqual(decoded);
    });

    it("harus melempar error jika refresh token tidak valid", () => {
      const encryptedToken = "invalidEncryptedRefreshToken";
      const decryptedToken = "invalidRefreshTokenMock";

      decrypt.mockReturnValue(decryptedToken);
      jwt.verify.mockImplementation(() => {
        throw new Error("Invalid token");
      });

      expect(() => verifyRefreshToken(encryptedToken)).toThrow("Invalid token");
      expect(decrypt).toHaveBeenCalledWith(encryptedToken);
      expect(jwt.verify).toHaveBeenCalledWith(
        decryptedToken,
        process.env.JWT_REFRESH_SECRET
      );
    });
  });

  describe("encrypt", () => {
    it("harus melempar error jika enkripsi gagal", () => {
      const text = "testToken";
      encrypt.mockImplementation(() => {
        throw new Error("Encryption failed");
      });

      expect(() => encrypt(text)).toThrow("Encryption failed");
      expect(encrypt).toHaveBeenCalledWith(text);
    });
  });

  describe("decrypt", () => {
    it("harus melempar error jika dekripsi gagal", () => {
      const encryptedText = "invalidEncryptedToken";
      decrypt.mockImplementation(() => {
        throw new Error("Decryption failed");
      });

      expect(() => decrypt(encryptedText)).toThrow("Decryption failed");
      expect(decrypt).toHaveBeenCalledWith(encryptedText);
    });

    it("harus melempar error jika format teks terenkripsi tidak valid", () => {
      const invalidFormat = "invalidFormatToken";
      decrypt.mockImplementation(() => {
        throw new Error("Format teks terenkripsi tidak valid");
      });

      expect(() => decrypt(invalidFormat)).toThrow(
        "Format teks terenkripsi tidak valid"
      );
      expect(decrypt).toHaveBeenCalledWith(invalidFormat);
    });
  });
});
======== FILE: ./src/utils/createStarterAccounts.js ========
import bcrypt from "bcrypt";
import { User } from "../models/index.js";
import logger from "../middlewares/loggingMiddleware.js";

export async function createStarterAccounts() {
  try {
    // Cek apakah sudah ada 'owner' di DB
    const ownerExist = await User.findOne({ where: { role: "owner" } });
    if (!ownerExist) {
      logger.info("Tidak ada Owner ditemukan. Membuat akun starter...");

      // Owner
      const ownerUsername = "owner";
      const ownerPassword = "owner123";
      const hashedOwner = await bcrypt.hash(ownerPassword, 10);

      await User.create({
        username: ownerUsername,
        password: hashedOwner,
        role: "owner",
        fullName: "Owner Master",
      });

      // Admin
      const adminUsername = "admin";
      const adminPassword = "admin123";
      const hashedAdmin = await bcrypt.hash(adminPassword, 10);

      await User.create({
        username: adminUsername,
        password: hashedAdmin,
        role: "admin",
        fullName: "Admin Master",
      });

      // User
      const userUsername = "user";
      const userPassword = "user123";
      const hashedUser = await bcrypt.hash(userPassword, 10);

      await User.create({
        username: userUsername,
        password: hashedUser,
        role: "user",
        fullName: "User Biasa",
      });

      logger.info(
        "Akun starter berhasil dibuat:\n" +
        "OWNER (username: owner, password: owner123)\n" +
        "ADMIN (username: admin, password: admin123)\n" +
        "USER (username: user, password: user123)"
      );
    } else {
      logger.info(
        "Akun owner sudah ada. Melewati pembuatan akun starter."
      );
    }
  } catch (error) {
    logger.error(`Error dalam membuat akun starter: ${error.message}`);
  }
}
======== FILE: ./src/utils/encryption.js ========
import crypto from 'crypto';
import logger from '../middlewares/loggingMiddleware.js';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY; // 64 karakter heksadesimal
const IV_LENGTH = 16; // Untuk AES, selalu 16

// Pastikan ENCRYPTION_KEY sudah diatur
if (!ENCRYPTION_KEY) {
  logger.error('ENCRYPTION_KEY tidak diatur di variabel lingkungan');
  throw new Error('ENCRYPTION_KEY tidak diatur di variabel lingkungan');
}

// Verifikasi panjang dan format ENCRYPTION_KEY
if (!/^[a-fA-F0-9]{64}$/.test(ENCRYPTION_KEY)) {
  logger.error('ENCRYPTION_KEY harus berupa string heksadesimal sepanjang 64 karakter');
  throw new Error('Format ENCRYPTION_KEY tidak valid');
}

// Log sebagian dari ENCRYPTION_KEY untuk verifikasi (hindari log seluruh kunci)
logger.info(`ENCRYPTION_KEY dimuat: ${ENCRYPTION_KEY.substring(0, 10)}...`);

export function encrypt(text) {
  try {
    let iv = crypto.randomBytes(IV_LENGTH);
    let cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    const encryptedToken = iv.toString('hex') + ':' + encrypted;
    logger.info(`Token berhasil dienkripsi: ${encryptedToken.substring(0, 30)}...`);
    return encryptedToken;
  } catch (error) {
    logger.error(`Error enkripsi: ${error.message}`);
    throw error;
  }
}

export function decrypt(text) {
  try {
    let textParts = text.split(':');
    if (textParts.length !== 2) {
      throw new Error('Format teks terenkripsi tidak valid');
    }
    let iv = Buffer.from(textParts[0], 'hex');
    let encryptedText = Buffer.from(textParts[1], 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    logger.info(`Token berhasil didekripsi: ${decrypted.substring(0, 30)}...`);
    return decrypted;
  } catch (error) {
    logger.error(`Error dekripsi: ${error.message}`);
    throw error;
  }
}
======== FILE: ./src/utils/token.js ========
import jwt from "jsonwebtoken";
import dotenv from "dotenv";
import { encrypt, decrypt } from "./encryption.js";
import logger from '../middlewares/loggingMiddleware.js';

dotenv.config();

// Pastikan ENCRYPTION_KEY ada dan valid (sudah dilakukan di encryption.js)

export function generateAccessToken(payload) {
  const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: "1d" });
  return encrypt(token);
}

export function generateRefreshToken(payload) {
  const token = jwt.sign(payload, process.env.JWT_REFRESH_SECRET, { expiresIn: "7d" });
  return encrypt(token);
}

export function verifyAccessToken(encryptedToken) {
  const token = decrypt(encryptedToken);
  return jwt.verify(token, process.env.JWT_SECRET);
}

export function verifyRefreshToken(encryptedToken) {
  const token = decrypt(encryptedToken);
  return jwt.verify(token, process.env.JWT_REFRESH_SECRET);
}
